use std::path::{Path, PathBuf};

pub const TEST_FROM: &[&str] = &["FROM /mnt/space/ollama/models/blobs/sha256-ff1d1fc78170d787ee1201778e2dd65ea211654ca5fb7d69b5a2e7b123a50373"];

pub const TEST_MODEL_IDS: &[&str] = &[
        "/mnt/space/ollama/models/blobs/sha256-ff1d1fc78170d787ee1201778e2dd65ea211654ca5fb7d69b5a2e7b123a50373",
        "llama3.1:latest",
    ];

pub const TEST_COMMENTS: &[&str] = &[
    r#"# Modelfile generated by "ollama show""#,
    r#"# To build a new Modelfile based on this, replace FROM with:"#,
    r#"# FROM llama3.1:latest"#,
];

pub const TEST_TRIPLE_QUOTES: &[&str] = &[r#""""here's some text
            in triple quotes
            we just need to consume it all
            and return it back
            """"#];

pub const TEST_SINGLE_QUOTE_MULTILINE: &[&str] = &[r#""here's some text
            in triple quotes
            we just need to consume it all
            and return it back
            ""#];

pub const TEMPLATE_PREFIX: &str = "TEMPLATE ";

/// The directory containing Modelfiles
pub const TEST_DATA_DIR: &str = "./test";

pub fn load_modelfiles(test_dir: impl AsRef<Path>) -> Vec<(PathBuf, String)> {
    test_dir
        .as_ref()
        .read_dir()
        .expect("could not open test data dir")
        .map(|file| {
            let file = file.expect("error reading dir entry");
            file.path()
        })
        .filter(|path| {
            path.extension()
                .unwrap()
                .to_str()
                .unwrap()
                .ends_with("Modelfile")
        })
        .map(|path| {
            (
                path.clone(),
                std::fs::read_to_string(&path).expect("could not read file contents"),
            )
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_data_loads() {
        let modelfiles: Vec<(PathBuf, String)> = load_modelfiles(TEST_DATA_DIR);
        assert!(!modelfiles.is_empty());
    }

}
