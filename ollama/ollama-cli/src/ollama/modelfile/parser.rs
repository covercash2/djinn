/// Parse the [`Modelfile`] according to the [Modelfile spec]
///
/// [Modelfile spec]: https://github.com/ollama/ollama/blob/main/docs/modelfile.md
use std::path::PathBuf;

use nom::{
    bytes::streaming::{tag, take_while1}, character::{complete, streaming}, combinator::value, error::context, multi::many0, sequence::{pair, preceded}, IResult, Parser as _
};

/// Takes an input string and returns a `ModelName`.
/// Parses a line that starts with `FROM`
/// that specifies the [`ModelId`]
pub fn from(input: &str) -> IResult<&str, &str> {
    let from_tag = tag("FROM");
    let space = take_while1(|c| c == ' ');

    context("FROM", preceded(pair(from_tag, space), model_id)).parse(input)
}

fn model_id(input: &str) -> IResult<&str, &str> {
    complete::not_line_ending(input)
}

#[derive(Debug, Clone)]
pub enum ModelId {
    VersionedModel { name: String, version: String },
    Path { path: PathBuf },
    Gguf { path: PathBuf },
}

/// Parse a comment line.
/// Comments start with a `#` and take a single line.
fn comment(input: &str) -> IResult<&str, ()> {
    let comment_delimeter = tag("#");

    context(
        "comment",
        value((), pair(comment_delimeter, complete::not_line_ending)),
    )
    .parse(input)
}

/// Consume empty lines and comments
fn skip_lines(input: &str) -> IResult<&str, ()> {
    context(
        "skip_lines",
        value(
            (),
            many0(comment)
        )
    )
        .parse(input)
}

#[cfg(test)]
mod tests {
    use std::path::Path;

    use super::*;

    const TEST_DATA_DIR: &str = "./test";

    fn load_modelfiles(test_dir: impl AsRef<Path>) -> Vec<String> {
        test_dir
            .as_ref()
            .read_dir()
            .expect("could not open test data dir")
            .map(|file| {
                let file = file.expect("error reading dir entry");
                file.path()
            })
            .filter(|path| path.ends_with("Modelfile"))
            .map(|path| std::fs::read_to_string(path).expect("could not read file contents"))
            .collect()
    }

    #[test]
    fn test_data_loads() {
        let _modelfiles: Vec<String> = load_modelfiles(TEST_DATA_DIR);
    }

    const TEST_FROM: &str = "FROM /mnt/space/ollama/models/blobs/sha256-ff1d1fc78170d787ee1201778e2dd65ea211654ca5fb7d69b5a2e7b123a50373";

    const TEST_MODEL_IDS: &[&str] = &[
        "/mnt/space/ollama/models/blobs/sha256-ff1d1fc78170d787ee1201778e2dd65ea211654ca5fb7d69b5a2e7b123a50373",
        "llama3.1:latest",
    ];

    #[test]
    fn from_field_is_parsed() {
        from(TEST_FROM).expect("should be able to parse single example");
    }

    #[test]
    fn model_name_is_parsed() {
        for model in TEST_MODEL_IDS {
            model_id(model).expect("could not parse model ID");
        }
    }

    const TEST_COMMENTS: &[&str] = &[
        r#"# Modelfile generated by "ollama show""#,
        r#"# To build a new Modelfile based on this, replace FROM with:"#,
        r#"# FROM llama3.1:latest"#,
    ];

    #[test]
    fn comments_are_parsed() {
        for comment_string in TEST_COMMENTS {
            comment(comment_string).expect("could not parse comments");
        }

        let long_comment = TEST_COMMENTS.iter()
            .fold(String::new(), |mut acc, line| {
                acc.push_str(line);
                acc.push('\n');
                acc.push('\n');
                acc
            });

        dbg!(&long_comment);

        skip_lines(long_comment.as_str()).expect("should skip all comment lines");
    }
}
